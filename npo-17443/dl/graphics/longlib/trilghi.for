	PROGRAM TRILGHI
C *** LAST REVISED ON  5-OCT-1987 07:27:37.09
C *** SOURCE FILE: [DL.GRAPHICS.LONGLIB]TRILGHI.FOR
C
C	CREATED:  DGL JULY 1987
C
C	THIS PROGRAM CONVERTS THE LONGLIB PRINTER HISTORY META FILE
C	INTO A DOT MATRIX PRINT FILE FOR A TRILOG PRINTER IN
C	HI-RESOLUTION MODE.
C
C	THIS PROGRAM IS FORTRAN 77 COMPATIBLE WITH THE EXCEPTIONS:
C		1. TABS (^I) ARE USED TO INDENT LINES.
C		2. A VAX DEPENDENT ROUTINE IS USED TO GET COMMAND LINE.
C		3. INTEGER*2 USED IN REGET ROUTINE.  THIS CAN BE CHANGED
C		   TO INTEGER IF THIS IS ALSO DONE IN LONGLIB PRINTER
C		   HISTORY ROUTINES LIBRARY.
C
C	MACHINE DEPENDENCIES:
C		1. USES CHAR TO RETURN THE CHARACTER OF ASCII VALUE
C		   IN A PARAMETER STATEMENT.
C		2. USES IBCLR AND IBSET TO SET BITS
C		3. THE COMMON BLOCK INITIALIZATIONS FOR RASTMAP
C		   MIGHT NEED CHANGING ON MACHINES WITH DIFFERENT WORD
C		   LENGTHS.
C		4. CONVERSIONS BETWEEN INTEGERS AND HOLLORITH CONSTANTS
C		   USED IN RSCOUT.
C		5. USES IAND AND IOR FOR BIT-WISE AND AND OR FUNCTIONS.
C
	CHARACTER*80 NAME
C
C	MACHINE DEPENDENT METHOD OF GETING THE FILE NAME FROM THE
C	RUN COMMAND LINE
C
	IERR=LIB$GET_FOREIGN(NAME,,IFLAG)
C
C	IF FILE NAME WAS NOT PRESENT ON ARGUMENT LINE THEN USE DEFAULT FILE NAME
C
	IF (NAME.EQ.' ') NAME='FOR003.DAT'
C
C	OPTION FLAGS
C	 ISTRIP = 1	ENABLES STRIPPING
C	 ISTRIP = 0	DISABLES STRIPPING
C	 IPRINT = 0	PROGRAM RUNS QUIETLY
C	 IPRINT = 1	PROGRAM PRINTS STATUS LINES
C
	ISTRIP=1
	IPRINT=1
C
C	OPEN PRINTER HISTORY FILE
C
	OPEN(UNIT=2,FILE=NAME,FORM='UNFORMATTED',STATUS='OLD',
     $		READONLY,ERR=299)
C
C	OPEN OUTPUT FILE
C
	OPEN(UNIT=3,FILE='OUT.LIS',FORM='FORMATTED',RECL=230,
     $		STATUS='NEW',ERR=399)
C
C	OPEN TEMPORARY WORKING FILE
C
	OPEN(UNIT=1,FILE='RASTER.TMP',FORM='UNFORMATTED',
     $		STATUS='SCRATCH',ERR=199,ACCESS='SEQUENTIAL')
C
C	SEND INITIALIZATION CODES TO PRINTER
C
	CALL PRINIT(3)
C
C	CONVERT LONGLIB META FILE INTO PRINTABLE FILE
C
	CALL RASCAN(1,2,3,ISTRIP,IPRINT)
C
C	SEND CLOSING CODES TO PRINTER
C
	CALL PRCLOS(3)
C
C	CLOSE FILE AND TERMINATE PROGRAM
C
	CLOSE(1)
	CLOSE(2)
	CLOSE(3)
	GOTO 999
C
C	FILE OPEN ERRORS
C
199	WRITE(*,198)
198	FORMAT(' *** COULD NOT OPEN TEMPORARY FILE ***')
	GOTO 999
299	WRITE(*,298)
298	FORMAT(' *** COULD NOT OPEN INPUT FILE ***')
	GOTO 999
399	WRITE(*,398)
398	FORMAT(' *** COULD NOT OPEN OUTPUT FILE ***')
	GOTO 999
C
999	STOP
	END
C
	SUBROUTINE PRINIT(LU)
C
C	SEND PRINTER INITIALIZATION CODES INTO OUTPUT FILE
C
	CHARACTER*(*) OPEN
C
C	FOR TRILOG HI-RES MODE <ESC>C
C
	PARAMETER (OPEN=CHAR(27)//CHAR(67))
	WRITE (LU,1) OPEN
1	FORMAT(X,A2)
	RETURN
	END
C
	SUBROUTINE PRCLOS(LU)
C
C	RESET PRINTER 
C
	CHARACTER*(*) CLOSE
C
C	FOR TRILOG <ESC>Q<ESC>Z
C
	PARAMETER (CLOSE=CHAR(27)//CHAR(81)//CHAR(27)//CHAR(90))
	WRITE (LU,1) CLOSE
1	FORMAT(X,A4)
	RETURN
	END
C
	SUBROUTINE NEWFORM(LU)
C
C	SET NEW PAGE TO PLOT ON
C
	CHARACTER*(*) ESCC
	PARAMETER (ESCC=CHAR(27)//CHAR(67))
C
	WRITE (LU,1) ESCC
1	FORMAT('1',X,A2)
	RETURN
	END
C
C
	SUBROUTINE RASCAN(LUT,LUI,LUO,ISTRIP,IPRINT)
C
C	INPUT:
C
C	LUT	(I)	OPEN TEMPORARY FILE LOGICAL UNIT NUMBER
C	LUI	(I)	INPUT FILE LOGICAL UNIT NUMBER
C	LUO	(I)	OUTPUT FILE LOGICAL UNIT NUMBER
C	ISTRIP	(I)	STRIPPING CONTROL FLAG (AUTO STRIPPING=1)
C	IPRINT	(I)	PRINT CONTROL FLAG (NO PRINT=0)
C
C	READ INPUT FILE, DECODE COMMANDS, REMOVE REDUNDANT COMMANDS,
C	ELIMINATE ORIGIN CHANGE COMMANDS, AND COPY TO TEMPORARY PEN
C	MOTION FILE.
C
C	LONGLIB META FILE COMMANDS
C
C	IC	COMMAND
C
C	2	PEN DOWN MOVE
C	3	PEN UP MOVE
C	-2	PEN DOWN MOVE WITH NEW ORIGIN
C	-3	PEN UP MOVE WITH NEW ORIGIN
C	9	PEN ERASE MOVE
C	-9	PEN ERASE WITH NEW ORIGIN
C	10	NEW PAGE
C	11	END OF FILE
C	999	END OF FILE
C	1000	SET RESOLUTION
C	1001	SET LINE TYPE
C	1002	SET PEN COLOR
C	1003	SET LINE WIDTH
C	(ELSE)	INVALID
C
C	FIRST COMMAND IN FILE SHOULD SET RESOLUTION
C	SECOND AND THIRD COMMANDS SHOULD SET LINE TYPE AND WIDTH
C
	INTEGER ICOM(13)
	DATA ICOM/2,3,-3,1001,1002,1003,10,-2,9,-9,11,999,1000/
	INTEGER ITRN(14)
	DATA ITRN/2,3, 3,   6,   5,  10, 8, 2,4, 4, 9,  9,   7,1/
	INTEGER M(128)
	LOGICAL BLANK,PENUP,LAST,PENWID,PENTYP
C
	COMMON /RAST/XSWIDE,YSWIDE,XRES,YRES,XLIM,YLIM,IXOFF,IYOFF,MAXSTR
C
C	SET PRINTER DEPENDENT PARAMETERS
C
	CALL SETPAR
C
C	SET MISC PARAMETERS
C
C	SX	DEFAULT X RESOLUTION OF HISTORY FILE (INCH/DOT)
C	SY	DEFAULT Y RESOLUTION OF HISTORY FILE (INCH/DOT)
C	IFIRST	FIRST OUTPUT PAGE FLAG
C
	SX=300.
	SY=400.
	IFIRST=0
C
C	INITIALIZE LAST LINE/COLOR
C
	LSC=1
	LWIDE=1
	LLINE=0
	LCOL=1
	PENWID=.TRUE.
	PENTYP=.TRUE.
C
C	INITIALIZE PAGE COUNTER
C
	NPAGE=1
	ICC=0
C
	IF (IPRINT.NE.0) WRITE(*,3000)
3000	FORMAT(' BEGIN RASTER SCAN CONVERSION')
C
C	INITIALIZE FILE BUFFERS
C
	MP=999
	NPCNT=1
C
C	INITIALIZE PAGE STRIP COUNTERS
C
12	CONTINUE
	IF (IPRINT.NE.0) WRITE(*,3010) NPAGE
3010	FORMAT(' BEGIN FIRST STRIP OF INPUT PAGE',I6)
	NXSTRIP=1
	NYSTRIP=1
	XMAX=0.
	YMAX=0.
C
C	NOTE THAT ORIGIN IS NOT PRESERVED OVER INPUT PAGE CHANGE
C
	XORG=0.
	YORG=0.
C
C	CHECK FOR COMPLETION OF TASK
C
	IF (ICC.EQ.11.OR.ICC.EQ.999) GOTO 110
C
C	START NEW STRIP
C
112	CONTINUE
C
C	INITIALIZE BLANK PAGE FLAG
C
	BLANK=.TRUE.
C
C	INITIALIZE LAST X,Y COMMANDS (LX,LY) ARE QUANTIZED VERSIONS
C
	PX=0.
	PY=0.
	LX=0
	LY=0
C
C	PENUP FLAG INDICATES POSITION OF PEN WHILE LAST FLAG INDICATES
C	WHETHER WE HAVE OUTPUT LAST COORDINATE
C
	PENUP=.TRUE.
	LAST=.FALSE.
C
C	READ EACH COMMAND IN HISTORY FILE
C
13	CALL REGET(M1,M2,ICC,MP,LUI,M)
C
C	CHECK FOR END OF FILE
C
	IF (ICC.EQ.11.OR.ICC.EQ.999) GOTO 10
C
C	DETERMINE COMMAND CODE
C
	DO 210 IC=1,13
		IF (ICOM(IC).EQ.ICC) GOTO 215
210	CONTINUE
	IC=14
215	CONTINUE
C
C	DECODE COMMAND AND EXECUTE
C
	GOTO (23,23,23,1001,1002,1003,10,23,23,23,10,10,1000) IC
	GOTO 13
C
C	HANDLE A PEN MOTION COMMAND
C
23	CONTINUE
C
C	CONVERT INPUT INTEGERS INTO REAL LOCATION VALUES
C
	Y1=M1*SY+YORG
	X1=M2*SX+XORG
C
C	DETERMINE MAXIMUM AND MINIMUM VALUES USED FOR X AND Y TO DETERMINE
C	HOW MUCH STRIPING IS NEEDED
C
	XMAX=AMAX1(XMAX,X1)
	YMAX=AMAX1(YMAX,Y1)
C
C	RESET ORIGIN
C
	IF (ICC.LT.0) THEN
		XORG=X1
		YORG=Y1
	ENDIF
C
C	CLIP LINE TO CURRENTLY VISIBLE STRIP
C
	X2=X1-(NXSTRIP-1)*XSWIDE
	Y2=Y1-(NYSTRIP-1)*YSWIDE
C
C	FOR PEN UP MOVES WE NEED ONLY STORE THE POINT
C
	IF (ITRN(IC).EQ.3) THEN
		PX=X2
		PY=Y2
		LX=-99
		LY=-99
		PENUP=.TRUE.
		LAST=.FALSE.
		GOTO 13
	ENDIF
C
C	GET CLIP FLAGS
C
	CALL CLIPS(IVT,XV1,YV1,XV2,YV2,X2,Y2,PX,PY,0.,0.,XLIM,YLIM)
C
C	CHECK FOR ENTIRELY INVISIBLE LINE
C
	IF (IVT.NE.0) THEN
		PX=X2
		PY=Y2
		LX=-99
		LY=-99
		PENUP=.TRUE.
		LAST=.FALSE.
		GOTO 13
	ENDIF
C
C	LINE IS AT LEAST PARTLY VISIBLE, SEND TO INTERMEDIATE PEN MOTION FILE
C	FIRST SEND LINE TYPE AND WIDTH IF NEEDED
C
	IF (PENTYP) THEN
		CALL PENOUT(LLINE,LSC,6,NPCNT,LUT)
		PENTYP=.FALSE.
	ENDIF
	IF (PENWID) THEN
		CALL PENOUT(LWIDE,LCOL,10,NPCNT,LUT)
		PENWID=.FALSE.
	ENDIF
C
C	SEND FIRST COORDINATE
C
	IX=IFIX(XV2*XRES+0.4999)+IXOFF
	IY=IFIX(YV2*YRES+0.4999)+IYOFF
	IF (.NOT.LAST.OR.IX.NE.LX.OR.IY.NE.LY) THEN
		CALL PENOUT(IX,IY,3,NPCNT,LUT)
		LAST=.TRUE.
		PENUP=.TRUE.
	ENDIF
	LX=IX
	LY=IY
	IX=IFIX(XV1*XRES+0.4999)+IXOFF
	IY=IFIX(YV1*YRES+0.4999)+IYOFF
	PX=X2
	PY=Y2
C
C	SEND SECOND COORDINATE IF NEEDED
C
	IF (PENUP.OR.IX.NE.LX.OR.IY.NE.LY) THEN
		CALL PENOUT(IX,IY,ITRN(IC),NPCNT,LUT)
	ENDIF
	PENUP=.FALSE.
	LX=IX
	LY=IY
C
C	IF VISIBLE PEN DOWN MOTION OCCURS THEN FLAG PAGE AS NOT BLANK
C
	IF (ITRN(IC).EQ.2) BLANK=.FALSE.
	GOTO 13
C
C	HANDLE NEW PAGE COMMANDS
C
10	CONTINUE
C
C	WRITE LAST RECORD TO TEMPORARY FILE
C
	CALL PENOUT(NXSTRIP,NYSTRIP,8,NPCNT,LUT)
C
C	REWIND TEMPORARY FILE
C
	REWIND(LUT)
C
C	OUTPUT CURRENT STRIP IF NOT BLANK
C
	IF (.NOT.BLANK) THEN
		IF (IFIRST.EQ.1) CALL NEWFORM(LUO)
		IF (IPRINT.NE.0) WRITE(*,3020) NXSTRIP,NYSTRIP
3020		FORMAT(' OUTPUT STRIP ',I6,',',I6)
		CALL MAKEP(LUT,LUO)
		REWIND(LUT)
		IFIRST=1
	ELSE
		IF (IPRINT.NE.0) WRITE(*,3030) NXSTRIP,NYSTRIP
3030		FORMAT(' BLANK STRIP ',I6,',',I6)
	ENDIF
C
C	COMPUTE NUMBER OF STRIPS NEEDED
C
	NXM=XMAX/XSWIDE+1
	NYM=YMAX/YSWIDE+1
C
C	IS STRIPPING ENABLED?  IF NOT INCREMENT PAGE AND CONTINUE
C
	IF (ISTRIP.NE.1) THEN
		IF (IPRINT.NE.0) WRITE(*,3045) NXSTRIP*NYSTRIP,NPAGE
3045		FORMAT(' STRIPPING DISABLED. ',I6,' STRIPS REQUIRED',
     $			' FOR INPUT PAGE',I6)
		NPAGE=NPAGE+1
		GOTO 12
	ENDIF
C
C	HAVE WE DONE ALL THE STRIPS THAT ARE REQUIRED?
C	IF NOT THEN REWIND INPUT FILE AND REPROCESS
C	OTHERWISE INCREMENT PAGE COUNTER AND PROCESS NEXT CASE
C
	IF (NXSTRIP.GE.NXM.AND.NYSTRIP.GE.NYM) THEN
		NPAGE=NPAGE+1
		GOTO 12
	ENDIF
C
C	NEW STRIP NUMBER
C
	IF (NXSTRIP.LT.NXM) THEN
		NXSTRIP=NXSTRIP+1
	ELSE
		NXSTRIP=1
		NYSTRIP=NYSTRIP+1
	ENDIF
C
C	WRITE WARNING IF NUMBER OF STRIPS EXCEEDS MAXIMUM
C
	IF (NXSTRIP*NYSTRIP.GT.MAXSTR.AND.NXSTRIP.EQ.1
     $		.AND.NYSTRIP.EQ.1) WRITE(*,3055) NXSTRIP*NYSTRIP,NPAGE
3055	FORMAT(' *** WARNING ',I6,' STRIPS REQUIRED FOR INPUT PAGE',I6)
C
	IF (IPRINT.NE.0) WRITE(*,3050) NXSTRIP,NYSTRIP,NXM,NYM
3050	FORMAT(' REREAD INPUT STRIP',I6,',',I6,'  OF ',I6,',',I6)
C
C REWIND INPUT FILE AND FIND CORRECT PAGE LOCATION
C
	REWIND(LUI)
	MP=999
C
C	FIND CORRECT LOCATION IN FILE
C
	IPGE=1
40	CONTINUE
C
C	IS THE CURRENT PAGE THE SAME AS THE PAGE POINTER IN THE FILE?
C	IF SO START NEW STRIP
C
	IF (IPGE.EQ.NPAGE) GOTO 112
45	CALL REGET(M1,M2,ICC,MP,LUI,M)
C
C	CHECK FOR END OF FILE -- IF WE HAVE REACHED IT WE ARE IN TROUBLE
C	SO EXIT WITH ERROR
C
	IF (ICC.EQ.11.OR.ICC.EQ.999) GOTO 199
C
C	COUNT UP NEW PAGE COMMANDS, SKIP THE REST
C
	IF (ICC.NE.10) GOTO 45
	IPGE=IPGE+1
	GOTO 40
C
C	SET RESOLUTION
C
1000	CONTINUE
C
C	CHECK FOR INPUT ERROR -- IF THERE IS, EXIT
C
	IF (M1.EQ.0.OR.M2.EQ.0) GOTO 110
	SX=1./FLOAT(M1)
	SY=1./FLOAT(M2)
	GOTO 13
C
C	CHANGE LINE TYPE COMMAND
C
1001	CONTINUE
C
C	M1 = LINE TYPE PATTERN MASK
C	M2 = LINE TYPE SCALE FACTOR
C
	IF (M1.NE.LLINE.OR.LSC.NE.M2) PENTYP=.TRUE.
	LLINE=M1
	LSC=M2
	GOTO 13
C
C	CHANGE COLOR COMMAND
C
1002	CONTINUE
C
C	M2 IS THE COLOR INDEX
C
	LCOL=M2
	GOTO 13
C
C	CHANGE LINE WIDTH COMMAND
C
1003	CONTINUE
C
C	M1 IS THE PEN WIDTH
C
	IF (M1.LT.0) M1=0
	IF (M1.NE.LWIDE.AND.M1.NE.0) THEN
		PENWID=.TRUE.
		LWIDE=M1
	ENDIF
	GOTO 13
C
C	ALL FINISHED WITH EVERYTHING
C
110	CONTINUE
	RETURN
C
199	CONTINUE
	WRITE(*,198)
198	FORMAT(' *** ERROR IN INPUT FILE REACHED END OF FILE EARLY ***')
	RETURN
	END
C
C
	SUBROUTINE CLIPS(IFLAG,XV1,YV1,XV2,YV2,X1,Y1,X2,Y2,XM,YM,XX,YX)
C
C	CLIPS THE LINE FROM X1,Y1 TO X2,Y2 TO THE RECTANCLE XM,YM XX,YX
C	CLIPPED LINE IS XV1,YV1 (CLIPPED X1,Y1) AND  XV2,YV2 (CLIPPED X2,Y2)
C
C	RETURNS IFLAG=-1 FOR ERROR, IFLAG<>0 FOR NOT VISIBLE, AND IFLAG=0
C	FOR AT LEAST PARTLY VISIBLE LINE
C
	XV1=X1
	YV1=Y1
	IV1=IPCLIP(XV1,YV1,XM,YM,XX,YX)
	XV2=X2
	YV2=Y2
	IV2=IPCLIP(XV2,YV2,XM,YM,XX,YX)
C
C	RETURN IF COMPLETELY VISIBLE OR INVISIBLE
C
	IFLAG=IOR(IV1,IV2)
	IF  (IFLAG.EQ.0) RETURN
	IFLAG=IAND(IV1,IV2)
	IF (IFLAG.NE.0) RETURN
C
C	OTHERWISE CLIP PARTIALLY VISIBLE LINE
C
	IC1=ICLIPS(IV1,XV1,YV1,X2,Y2,XM,YM,XX,YX)
	IC2=ICLIPS(IV2,XV2,YV2,X1,Y1,XM,YM,XX,YX)
	RETURN
	END
C
	INTEGER FUNCTION ICLIPS(IV,XV,YV,X2,Y2,XM,YM,XX,YX)
C
C	CLIPS LEFT SIDE LINE FROM XV,YV TO X2,V2 IN BOX XM,YM,XX,YX
C
C	CLIP LEFT EDGE
C
	IF (IAND(IV,1).NE.0) THEN
		YV=YV+(Y2-YV)*(XM-XV)/(X2-XV)
		XV=XM
		IV=IPCLIP(XV,YV,XM,YM,XX,YX)
	ENDIF
C
C	CLIP RIGHT EDGE
C
	IF (IAND(IV,2).NE.0) THEN
		YV=YV+(Y2-YV)*(XX-XV)/(X2-XV)
		XV=XX
		IV=IPCLIP(XV,YV,XM,YM,XX,YX)
	ENDIF
C
C	CLIP BOTTOM EDGE
C
	IF (IAND(IV,4).NE.0) THEN
		XV=XV+(X2-XV)*(YM-YV)/(Y2-YV)
		YV=YM
		IV=IPCLIP(XV,YV,XM,YM,XX,YX)
	ENDIF
C
C	CLIP TOP EDGE
C
	IF (IAND(IV,8).NE.0) THEN
		XV=XV+(X2-XV)*(YX-YV)/(Y2-YV)
		YV=YX
		IV=IPCLIP(XV,YV,XM,YM,XX,YX)
	ENDIF
	ICLIPS=IV
	RETURN
	END
C
	SUBROUTINE REGET(M1,M2,M3,MP,ILU,M)
C
C	READ DATA FROM LONGLIB PRINTER HISTORY META FILE
C	
	INTEGER*2 M(128)
	MP=MP+3
	IF (MP.GT.128) THEN
		READ (ILU,ERR=99) M
		MP=3
	ENDIF
	M3=M(MP)
	M2=M(MP-1)
	M1=M(MP-2)
	IF (M3.EQ.999) GOTO 99
	RETURN
99	M3=11
	RETURN
	END
C
	SUBROUTINE PENOUT(M1,M2,M3,MP,ILU)
C
C	WRITE DATA TO TEMPORARY FILE
C	
	INTEGER*2 M(128)
	M(MP)=M1
	M(MP+1)=M2
	M(MP+2)=M3
	MP=MP+3
	IF (MP.GE.126.OR.M3.EQ.8) THEN
		WRITE (ILU,ERR=99) M
		MP=1
	ENDIF
	RETURN
99	WRITE(*,10)
10	FORMAT(' *** ERROR WRITING RASTER SCAN TEMPORARY FILE ***')
	CALL EXIT
	END
C
C
	INTEGER FUNCTION IPCLIP(X,Y,XM,YM,XX,YX)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	CHECKS TO SEE IF POINT XY IS IN RECTANGLE (XM,YM)-(XX,YX)
C	OR ON THE BOUNDRY -- RETURNS ZERO OR A CODE INDICATING POSITION
C
	INTEGER CD
	CD=0
	IF (X.LT.XM) THEN
		CD=1
	ELSE
		IF (X.GT.XX) CD=2
	ENDIF
	IF (Y.LT.YM) THEN
		CD=CD+4
	ELSE
		IF (Y.GT.YX) CD=CD+8
	ENDIF
	IPCLIP=CD
	RETURN
	END
C
C
	SUBROUTINE SETPAR
C
C	SET PRINTER DEPENDENT PARAMETERS
C
	COMMON /RAST/XSWIDE,YSWIDE,XRES,YRES,XLIM,YLIM,IXOFF,IYOFF,MAXSTR
C
C	XSWIDE	LENGTH OF STRIP IN X DIRECTION (INCH) (XSWIDE<=XLIM)
C	YSWIDE	LENGTH OF STRIP IN X DIRECTION (INCH) (YSWIDE<=YLIM)
C	XRES	OUTPUT DEVICE RESOLUTION IN X DIRECTION (DOT/INCH)
C	YRES	OUTPUT DEVICE RESOLUTION IN Y DIRECTION (DOT/INCH)
C	XLIM	LIMIT OF MOTION IN X DIRECTION (INCH)
C	YLIM	LIMIT OF MOTION IN Y DIRECTION (INCH)
C	IXOFF	X OFFSET (DOTS)
C	IYOFF	Y OFFSET (DOTS)
C	MAXSTR	MAXIMUM NUMBER OF STRIPS BEFORE WARNING
C
	COMMON /RASTMAP/NMAP,MMAP,NBW,NWORD,ALONGP,BLONGP,
     $		CROSSP,IMAP(11881)
C
C	NMAP	BIT MAP DIMENSION ALONG PAGE DIRECTION (DOTS)
C	MMAP	BIT MAP DIMENSION CROSS PAGE DIRECTION (DOTS)
C	NBW	BITS PER RASTER SCAN BUFFER WORD
C	NWORD	BITS PER OUTPUT BUFFER WORD
C	ALONGP	END BITS OF CURRENT RASTER BAND ALONG PAGE DIRECTION
C	BLONGP	START BITS OF CURRENT RASTER BAND ALONG PAGE DIRECTION
C	CROSSP	FLOAT MMAP-1
C	IMAP	BIT MAP BUFFER DIMENSIONED AT LEAST (NMAP*MMAP)/NBW+1
C
C	INITIALIZE DEVICE COMMON BLOCK
C
	XSWIDE=75.0
	YSWIDE=13.0
	XLIM=77.0
	YLIM=13.2
	XRES=72.
	YRES=100.
	IXOFF=0
	IYOFF=0
	MAXSTR=6
C
C	INITIALIZE RASTER BAND COMMON BLOCK
C
	NMAP=288
	MMAP=1320
	NBW=32
	NWORD=6
	CROSSP=MMAP-1
	ALONGP=NMAP-1
	BLONGP=0.
C
	RETURN
	END
C
C
	SUBROUTINE MAKEP(LUT,LUO)
C
C	READ PEN MOTION FILE AND CONVERT TO RASTER SCAN
C
	INTEGER M(128)
	COMMON /RASTMAP/NMAP,MMAP,NBW,NWORD,ALONGP,BLONGP,
     $		CROSSP,IMAP(11881)
C
C	ARRAYS FOR LINE WIDTH AND TYPE
C
	INTEGER MWP(7),MWX(44),MWY(44),B(16)
	DATA MWP/1,5,12,21,26,37,44/
	DATA MWX/0,-1,1,1,-1,-1,0,2,1,0,0,-1,0,-1,-1,-1,0,0,1,1,1,1,
     $   1,0,0,-1,-1,-1,-1,-1,-1,0,0,1,1,1,1,1,1,1,0,0,-1,-1/
	DATA MWY/0,0,1,-1,-1,0,2,0,0,-1,-1,0,-1,0,0,1,1,1,1,0,0,0,-1,
     $   -1,-1,-1,-1,0,0,1,1,1,1,1,1,0,0,0,-1,-1,-1,-1,-1,-1/
C
C	LINE TYPE BIT MAPS (16 BITS)
C
	INTEGER ILT(16)
	DATA ILT/-1,21845,13311,16191,8191,13119,16359,255,23485,
     $	 13107,7295,15567,22015,3855,24383,23485/
	DATA NTYPE/16/
C
C	MAKE A PASS THROUGH FILE FOR EACH RASTER BAND
C
	NBAND=1
	NMAX=1
C
500	CONTINUE
	ALONGP=NBAND*NMAP-1
	BLONGP=(NBAND-1)*NMAP
C
C	DEFAULT SOLID LINE WITH UNIT WIDTH AND SCALE FACTOR
C
	LWIDE=1
	LSC=1
	LTYPE=0
	DO 5 I=1,16
		B(I)=1
5	CONTINUE
C
C	CLEAR RASTER SCAN BUFFER
C
	CALL CLRRSC
C
	LX=0
	LY=0
	MP=999
C
C	READ EACH COMMAND IN HISTORY FILE
C
10	CALL REGET(M1,M2,IC,MP,LUT,M)
C
C	DECODE COMMAND AND EXECUTE
C
	GOTO (10,20,30,40,50,60,10,80,80,55,10) IC
	GOTO 80
C
C	PEN DOWN MOVE
C
20	CONTINUE
	IVIS=1
22	CONTINUE
C
C	ADD THE LINE SEGMENT (LX,LY) TO (M1,M2) TO BIT MAP
C	ADD LINE SEGMENT (SEVERAL TIMES FOR LINE WIDTH)
C	COORDINATE FOR PRINTER PAGE
C		X CORRESPONDS TO ALONG PAGE DIRECTION
C		Y CORRESPONDS TO CROSS PAGE DIRECTION
C
	LW=MWP(LWIDE)
	IX1=LX
	IY1=LY
	IX2=M1
	IY2=M2
	DO 25 IW=1,LW
		IX1=IX1+MWX(IW)
		IY1=IY1+MWY(IW)
		IX2=IX2+MWX(IW)
		IY2=IY2+MWY(IW)
		NMAX=MAX(NMAX,IX1)
		NMAX=MAX(NMAX,IX2)
		CALL RSCBIT(LSC,IVIS,IX1,IY1,IX2,IY2,B,ICNT)
25	CONTINUE
	LX=M1
	LY=M2
C
	GOTO 10
C
C	PEN UP MOVE
C
30	CONTINUE
	LX=M1
	LY=M2
	GOTO 10
C
C	ERASE PEN MOVE	
C
40	CONTINUE
	IVIS=0
	GOTO 22
c
50	CONTINUE
C
C	PEN COLOR
C
	LCOL=M2
C
	GOTO 10
C
C	CHANGE PEN WIDTH
C
55	CONTINUE
C
C	RESTRICT RANGE OF PERMISSIBLE LINE WIDTHS
C
	LWIDE=MAX(1,M1)
	LWIDE=MIN(LWIDE,7)
	type *,'pen width',m1,lwide
	GOTO 10
C
C	CHANGE LINE TYPE AND SCALE
C
60	CONTINUE
C
	LTYPE=M1+1
	IF (LTYPE.LT.1) LTYPE=1
	IF (LTYPE.GT.NTYPE) LTYPE=MOD(LTYPE,NTYPE)
	LTYPE=ILT(LTYPE)
	LSC=M2
	IF (LSC.LT.1) LSC=1
	IF (LSC.GT.7) LSC=7
C
C	GET BIT MAP FOR LINE TYPE
C
	DO 75 I=1,16
		B(I)=IBITS(LTYPE,I-1,1)
75	CONTINUE
C
C	SCALE FACTOR
C
	LSC=M2
	IF (LSC.LT.1) LSC=1
	IF (LSC.GT.8) LSC=8
	GOTO 10
C
C	END OF FILE REACHED
C
80	CONTINUE
C
C	DUMP BUFFER TO OUTPUTFILE
C
	CALL RSCOUT(LUO)
C
C	DONE WITH ALL PASSES?
C
	IF (NBAND*NMAP-1.LT.NMAX) THEN
C
C	IF NOT, INCREMENT BAND COUNTER, REWIND TEMP FILE AND PROCESS AGAIN
C
		NBAND=NBAND+1
		REWIND(LUT)
		GOTO 500
	ENDIF
C
C	FINISHED
C
	RETURN
	END
C
	SUBROUTINE CLRRSC
C
C	CLEAR RASTER SCAN CONVERTER BUFFER
C
	COMMON /RASTMAP/NMAP,MMAP,NBW,NWORD,ALONGP,BLONGP,
     $		CROSSP,IMAP(11881)
	NN=(NMAP*MMAP)/NBW+1
	DO 10 I=1,NN
		IMAP(I)=0
10	CONTINUE
	RETURN
	END
C
C
	SUBROUTINE RSCOUT(LUO)
C
C	OUTPUT RASTER SCAN CONVERTER BUFFER TO FILE
C
	COMMON /RASTMAP/NMAP,MMAP,NBW,NWORD,ALONGP,BLONGP,
     $		CROSSP,IMAP(11881)
	INTEGER OUT(300)
C
	DATA ISPACE/32/,ICTRLE/5/
C
C	COMPUTE NUMBER OF OUTPUT WORDS
C
	NOUT=MMAP/NWORD
	IF (MOD(MMAP,NWORD).NE.0) NOUT=NOUT+1
	MM1=MMAP-1
C
C	FOR EACH ALONG PAGE LINE IN THE RASTER SCAN BUFFER
C
	DO 10 I=1,NMAP
C
C	INITIALIZE OUTPUT BUFFER
C
		DO 2 J=1,NOUT
			OUT(J)=64
2		CONTINUE
C
C	COPY LINE INTO OUTPUT BUFFER
C
		NX=(I-1)*MMAP
		DO 5 J=0,MM1
			IWOR=(NX+J)/NBW+1
			IF (IMAP(IWOR).EQ.0) GOTO 5
			IBIT=MOD(NX+J,NBW)
			IOUT=IBITS(IMAP(IWOR),IBIT,1)
			IF (IOUT.NE.0) THEN
				IWOR=J/NWORD+1
				IBIT=MOD(J,NWORD)
				OUT(IWOR)=IBSET(OUT(IWOR),IBIT)
			ENDIF
5		CONTINUE	
C
C	COMPUTE OUTPUT LINE LENGTH
C	
		DO 6 J=1,NOUT
			JJ=NOUT-J+1
			IF (OUT(JJ).GT.64) GOTO 8
6		CONTINUE
8		MLEN=JJ
		WRITE(LUO,25) ISPACE,ICTRLE,(OUT(J),J=1,MLEN)
25		FORMAT(2A1,219A1)
10	CONTINUE
	RETURN
	END
C
C
	SUBROUTINE RSCBIT(LSC,IVIS,IX1,IY1,IX2,IY2,B,ICNT)
C
C	PUT VECTOR SEGMENT INTO RASTER SCAN BYTE MAP
C
C	LSC	(I)	LINE TYPE SCALE FACTOR
C	IVIS	(I)	IVIS=WRITE, IVIS=0 ERASE
C	IX1,IY1	(I)	START POINT OF LINE SEGMENT
C	IX2,IY2	(I)	START POINT OF LINE SEGMENT
C	B	(I)	16 ELEMENT ARRAY OF BIT MAP FOR LINE TYPE
C	ICNT	(I)	COUNTER FOR LINE TYPE
C
	INTEGER B(16)
	COMMON /RASTMAP/NMAP,MMAP,NBW,NWORD,ALONGP,BLONGP,
     $		CROSSP,IMAP(11881)
	INTEGER DX,DY,X,Y,X1,Y1,X2,Y2,DIF,D
	LOGICAL INV
C
C	GET CLIP FLAGS FOR THIS RASTER BAND
C
	CALL CLIPS(IVT,XV1,YV1,XV2,YV2,
     $	 	FLOAT(IX1),FLOAT(IY1),FLOAT(IX2),FLOAT(IY2),
     $		BLONGP,0.,ALONGP,CROSSP)
C
C	CHECK FOR LINE COMPLETELY OUT OF BAND
C
	IF (IVT.NE.0) RETURN
C
C	CLIPPED LINE SEGMENT IS AT LEAST PARTLY VISIBLE
C
	X1=IFIX(XV1-BLONGP+0.01)
	Y1=IFIX(YV1+0.01)
	X2=IFIX(XV2-BLONGP+0.01)
	Y2=IFIX(YV2+0.01)
C
C	PUT CLIPPED SEGMENT INTO BAND
C
	DX=IABS(X1-X2)
	DY=IABS(Y1-Y2)
	INV=.FALSE.
	IF (DX.LT.DY) THEN
		X=X1
		X1=Y1
		Y1=X
		X=X2
		X2=Y2
		Y2=X
		X=DY
		DY=DX
		DX=X
		INV=.TRUE.
	ENDIF
	IF (X2.LT.X1) THEN
		X=X1
		X1=X2
		X2=X
		Y=Y1
		Y1=Y2
		Y2=Y
	ENDIF
	DIF=1
	IF (Y2.LT.Y1) DIF=-1
	D=2*DY-DX
	I1=2*DY
	I2=2*(DY-DX)
	Y=Y1
C
	DO 10 X=X1,X2
		ICNT=ICNT+1
		IBT=MOD(ICNT/LSC,16)+1
		ICNT=MOD(ICNT,LSC*16)
		IF (B(IBT).NE.0) THEN
			IF (INV) THEN
				IWOR=(Y*MMAP+X)/NBW+1
				IBIT=MOD(Y*MMAP+X,NBW)
			ELSE
				IWOR=(X*MMAP+Y)/NBW+1
				IBIT=MOD(Y+X*MMAP,NBW)
			ENDIF
			IF (IVIS.EQ.0) THEN
				IMAP(IWOR)=IBCLR(IMAP(IWOR),IBIT)
			ELSE
				IMAP(IWOR)=IBSET(IMAP(IWOR),IBIT)
			ENDIF
		ENDIF
5		IF (D.LT.0) THEN
			D=D+I1
		ELSE
			D=D+I2
			Y=Y+DIF
		ENDIF
10	CONTINUE
	RETURN
	END
